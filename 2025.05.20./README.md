# 📌 OTP 인증 기능 개선 작업 기록

## 📝 개요
OTP 인증 기능을 기존 SMS 방식 중심에서 **회사 설정에 따라 동적으로 SMS 또는 FCM(Google Push)** 방식으로 전송할 수 있도록 개선하였다.  
또한 OTP 요청 → 저장 → 검증 → 인증 흐름을 **유연하게 처리할 수 있도록 구조화**하고, **다중 디바이스 로그인 정책**을 반영한 로그인 로직도 함께 구성하였다.

---

## ⚙️ 주요 기능 흐름 정리

### 1. OTP 요청

#### ✅ 요청 조건
- 요청자는 반드시 이메일과 휴대폰 번호를 함께 입력해야 함
- 회사 설정에서 OTP 사용 여부(`isOtpUsed`) 및 전송 방식(`otpType`)을 기준으로 분기 처리됨

#### ✅ 전송 방식 분기
- `"SMS"`: 통신사(KT/LG/SKT) 설정을 통해 `MyBatis`로 SMS 전송 처리
- `"GOOGLE_PUSH"`: Firebase Token을 이용해 FCM으로 OTP 전송

#### ✅ OTP 생성 및 저장
```java
int otp = OtpProvider.generateOTP(mobileNo, otpDuration, now.toString());
```
- 생성된 OTP는 DB에 저장되며, 실패 시 저장되지 않음
- `otpDuration`은 설정 파일로부터 주입됨

---

### 2. OTP 검증 (`verifyOtp`)

#### ✅ 검증 로직
- 요청된 OTP 값과 DB에 저장된 OTP 값을 비교
- OTP가 일치하지 않지만 10초 이내로 발급된 OTP일 경우 재생성 후 한 번 더 비교
- 최종적으로 일치하지 않으면 실패 처리, 일치하면 DB에서 삭제

---

### 3. 인증 완료 후 로그인 처리

#### ✅ 토큰 기반 자동로그인 흐름
- `Authorization` 헤더에 JWT가 존재하면 토큰 검증 후 바로 인증 성공 처리
- 이때 `userId`, `corpCode`를 기반으로 사용자 정보 확인

#### ✅ OTP 인증 성공 후 로그인 처리
- OTP 일치 시, `loginService.login(user)`을 통해 JWT 발급
- 로그인 실패 카운트 초기화
- 디바이스 정보 저장 및 히스토리 기록

---

### 4. 디바이스 중복 로그인 정책 처리

#### ✅ 정책 기준
- 회사별 중복 로그인 허용 여부(`multiDeviceUsed`)와 전역 설정(`isAllowDuplication`)을 기준으로 판별
- 최대 허용 디바이스 수 초과 시 오류 반환

---

## 🔐 OTP 전송 방식 세부 구현

### ✅ SMS 전송 (KT/LG/SKT)
- 통신사 구분 후 각각 다른 쿼리 매퍼 사용
- 수신 번호, 메시지, 발신자 정보를 구성하여 `MyBatis`로 DB 삽입 → 외부 시스템이 문자 전송 처리

### ✅ FCM 전송 (Google Push)
- Firebase 인증키를 `.yml` 경로에서 주입받아 초기화
- 토큰을 기반으로 Firebase 메시지를 구성하여 전송
```java
FirebaseMessaging.getInstance(firebaseApp).send(message);
```

---

## 📌 작업하면서 정리한 주요 사항

- OTP 전송 방식은 회사 설정(`otpType`)에 따라 동적으로 선택됨
- OTP 요청 시 유효성 검사는 물론 예외 케이스(예: FCM 토큰 없음)까지 고려하여 처리함
- OTP 인증 흐름은 단방향이 아니라 예외적 상황까지 유연하게 대응할 수 있어야 함
- **FCM Push는 Firebase 초기화, 메시지 포맷, 예외 처리 등 사전 준비가 중요**
- **디바이스 중복 로그인 정책**은 회사 요구사항에 따라 다르게 동작해야 하므로 설정 기반 조건을 명확히 분리

---

## ✅ 향후 개선 방향

- OTP 실패 내역 로깅 및 시도 제한 로직 추가
- FCM 실패 원인 분석 로그 구조화
- 디바이스 히스토리 모니터링 기능 UI에 연동
- 카카오 알림톡 연동 방식도 통합적으로 관리 가능하도록 추상화
